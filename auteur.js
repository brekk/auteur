// Generated by CoffeeScript 1.7.1
(function() {
  "use strict";

  /*
  DEPENDENCIES
   */
  var Deferred, auteur, capitalize, classConstants, define, emitter, events, fs, promise, _, __constant, __hidden, __hiddenContext, __lookupHidden, __mutable, __private, __protected, __public, __writable;
  _ = require('lodash');
  events = require('events');
  emitter = new events.EventEmitter();
  promise = require('promised-io');
  Deferred = promise.Deferred;
  fs = require('fs');

  /**
  * The Auteur is the automaton that manages the differences between different implementations.
  * It behaves as a singleton (per thread/process), and is modeled after gulp and winston.
  * @class Auteur
   */
  auteur = exports;
  require('pkginfo')(module, 'version');

  /*
  PROPERTY DEFINITIONS!
   */
  define = function(prop, value, settings, onObject) {
    if (onObject == null) {
      onObject = auteur;
    }
    settings = _.assign({
      enumerable: true,
      writable: true,
      configurable: true
    }, settings);
    if (value != null) {
      settings.value = value;
    }
    return Object.defineProperty(onObject, prop, settings);
  };
  __mutable = function(prop, value) {
    return define(prop, value);
  };
  __private = function(prop, value) {
    var settings;
    settings = {
      enumerable: false,
      writable: true,
      configurable: false
    };
    return define(prop, value, settings);
  };
  __public = function(prop, value) {
    var settings;
    settings = {
      enumerable: true,
      writable: false,
      configurable: false
    };
    return define(prop, value, settings);
  };
  __writable = function(prop, value) {
    var settings;
    settings = {
      enumerable: true,
      writable: true,
      configurable: false
    };
    return define(prop, value, settings);
  };
  __constant = function(prop, value) {
    var settings;
    settings = {
      enumerable: false,
      writable: false,
      configurable: false
    };
    return define(prop, value, settings);
  };
  __protected = function(prop, value) {
    var settings;
    return settings = {
      enumerable: false,
      writable: false,
      configurable: true
    };
  };
  __hiddenContext = {};
  __hidden = function(prop, value) {
    if (__hiddenContext[prop] == null) {
      define(prop, value, {}, __hiddenContext);
      return true;
    }
    return false;
  };
  __lookupHidden = function(key) {
    if (__hiddenContext[key] != null) {
      return __hiddenContext[key];
    }
    return void 0;
  };

  /*
  CONSTANTS
   */
  classConstants = {
    _CLASS_PROJECT: 'project',
    _CLASS_POST: 'post',
    _CLASS_AUTHOR: 'author',
    _CLASS_BOOKMARK: 'bookmark'
  };
  _(classConstants).each(function(value, key) {
    return __constant(key, value);
  });

  /**
  * classes constant, for array convenience
  * @property _classes
  * @type Array
   */
  __constant('_classes', _.values(classConstants));
  _(emitter).methods().each(function(fxName) {
    return __public(fxName, function() {
      return emitter[fxName].apply(auteur, arguments);
    });
  });

  /**
  * Checks a given classname against our _classes listing
  * @method isValidClass
  * @param {String} className - a possibly valid class name
  * @return {Boolean} validClass
   */
  __public('isValidClass', function(className) {
    if (!_.isString(className)) {
      return false;
    }
    return _.contains(auteur._classes, className.toLowerCase());
  });

  /**
  * As the name suggests, throws an error if given not-a-class
  * @method throwOnInvalidClass
  * @param {String} x - a possibly valid class name
  * @private
   */
  __private('throwOnInvalidClass', function(x) {
    if (x == null) {
      throw new TypeError("Expected class to be defined.");
    }
    if (!_.isString(x)) {
      throw new TypeError("Expected class to be string.");
    }
    if (!this.isValidClass(x)) {
      throw new TypeError("Expected class to be one of [ " + (auteur._classes.join(', ')) + " ].");
    }
  });
  capitalize = function(x) {
    var capped, first, rest;
    if (_.isString(x)) {
      first = x.substr(0, 1).toUpperCase();
      rest = x.substr(1);
      capped = first + rest;
      return capped;
    }
    return x;
  };

  /**
  * A validator and single location for calling a bunch of possible sub-functions
  * @method create
  * @param {String} kind - create what kinda thing?
   */
  __public('create', function(kind) {
    var args, methodName;
    this.throwOnInvalidClass(kind);
    args = _.rest(arguments);
    console.log(">> auteur create " + kind);
    methodName = '_create' + capitalize(kind);
    if (this[methodName] != null) {
      return this[methodName].apply(this, args);
    }
    throw new Error("Expected " + methodName + " to be valid method.");
  });
  __private('_createProject', function() {
    return console.log("createProject", arguments);
  });
  __private('_createPost', function() {
    return console.log("createPost", arguments);
  });
  __private('_createAuthor', function() {
    return console.log("createAuthor", arguments);
  });
  __private('_createBookmark', function() {
    return console.log("createBookmark", arguments);
  });
  __public('test', function(kind) {
    var args, methodName;
    this.throwOnInvalidClass(kind);
    args = _.rest(arguments);
    console.log(">> auteur test " + kind);
    methodName = '_test' + capitalize(kind);
    if (this[methodName] != null) {
      return this[methodName].apply(this, args);
    }
    throw new Error("Expected " + methodName + " to be valid method.");
  });
  __private('_testProject', function() {
    return console.log("testProject", arguments);
  });
  __private('_testPost', function() {
    return console.log("testPost", arguments);
  });
  __private('_testAuthor', function() {
    return console.log("testAuthor", arguments);
  });
  __private('_testBookmark', function() {
    return console.log("testBookmark", arguments);
  });
  __private('_spiderDirectory', function(location, exclude, announce) {
    var absolutePathWalk, d, self, walk;
    self = this;
    if (exclude == null) {
      exclude = [];
    }
    if (announce == null) {
      announce = [];
    }
    d = new Deferred();
    d.yay = _.once(d.resolve);
    d.nay = _.once(d.reject);
    walk = function(dir, done) {
      var results;
      results = [];
      return fs.readdir(dir, function(err, list) {
        var pending;
        if (err) {
          return done(err);
        }
        list = _.pull.apply(_, [list].concat(exclude));
        pending = list.length;
        if (!pending) {
          return done(null, results);
        }
        return _(list).each(function(file) {
          var filename;
          filename = file;
          file = "" + dir + "/" + file;
          return fs.stat(file, function(err, stat) {
            if (_.contains(announce, filename)) {
              self.emit('fileMatch', filename);
            }
            if (stat != null ? typeof stat.isDirectory === "function" ? stat.isDirectory() : void 0 : void 0) {
              return walk(file, function(err, res) {
                if (err != null) {
                  return done(err);
                }
                results = results.concat(res);
                if (!--pending) {
                  return done(null, results);
                }
              });
            } else {
              results.push(file);
              if (!--pending) {
                return done(null, results);
              }
            }
          });
        });
      });
    };
    absolutePathWalk = function(err, path) {
      if (err != null) {
        return d.nay(err);
      }
      return walk(path, function(err, out) {
        if (err) {
          return d.nay(err);
        }
        return d.yay(out);
      });
    };
    fs.realpath(location, absolutePathWalk);
    return d;
  });
  return exports;
}).call(this);
