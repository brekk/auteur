// Generated by CoffeeScript 1.7.1
(function() {
  "use strict";

  /*
  DEPENDENCIES
   */
  var auteur, capitalize, classConstants, define, emitter, events, _, __constant, __hidden, __hiddenContext, __lookupHidden, __mutable, __private, __protected, __public, __writable;
  _ = require('lodash');
  events = require('events');
  emitter = new events.EventEmitter();

  /**
  * The Auteur is the automaton that manages the differences between different implementations.
  * It behaves as a singleton (per thread/process), and is modeled after gulp and winston.
  * @class Auteur
   */
  auteur = exports;
  require('pkginfo')(module, 'version');

  /*
  PROPERTY DEFINITIONS!
   */
  define = function(prop, value, settings, onObject) {
    if (onObject == null) {
      onObject = auteur;
    }
    settings = _.assign({
      enumerable: true,
      writable: true,
      configurable: true
    }, settings);
    if (value != null) {
      settings.value = value;
    }
    return Object.defineProperty(onObject, prop, settings);
  };
  __mutable = function(prop, value) {
    return define(prop, value);
  };
  __private = function(prop, value) {
    var settings;
    settings = {
      enumerable: false,
      writable: true,
      configurable: false
    };
    return define(prop, value, settings);
  };
  __public = function(prop, value) {
    var settings;
    settings = {
      enumerable: true,
      writable: false,
      configurable: false
    };
    return define(prop, value, settings);
  };
  __writable = function(prop, value) {
    var settings;
    settings = {
      enumerable: true,
      writable: true,
      configurable: false
    };
    return define(prop, value, settings);
  };
  __constant = function(prop, value) {
    var settings;
    settings = {
      enumerable: false,
      writable: false,
      configurable: false
    };
    return define(prop, value, settings);
  };
  __protected = function(prop, value) {
    var settings;
    return settings = {
      enumerable: false,
      writable: false,
      configurable: true
    };
  };
  __hiddenContext = {};
  __hidden = function(prop, value) {
    if (__hiddenContext[prop] == null) {
      define(prop, value, {}, __hiddenContext);
      return true;
    }
    return false;
  };
  __lookupHidden = function(key) {
    if (__hiddenContext[key] != null) {
      return __hiddenContext[key];
    }
    return void 0;
  };

  /*
  CONSTANTS
   */
  classConstants = {
    _CLASS_PROJECT: 'project',
    _CLASS_POST: 'post',
    _CLASS_AUTHOR: 'author',
    _CLASS_BOOKMARK: 'bookmark'
  };
  _(classConstants).each(function(value, key) {
    return __constant(key, value);
  });

  /**
  * classes constant, for array convenience
  * @property _classes
  * @type Array
   */
  __constant('_classes', _.values(classConstants));
  _(emitter).methods().each(function(fxName) {
    return __public(fxName, function() {
      return emitter[fxName].apply(auteur, arguments);
    });
  });

  /**
  * Checks a given classname against our _classes listing
  * @method isValidClass
  * @param {String} className - a possibly valid class name
  * @return {Boolean} validClass
   */
  __public('isValidClass', function(className) {
    if (!_.isString(className)) {
      return false;
    }
    return _.contains(auteur._classes, className.toLowerCase());
  });

  /**
  * As the name suggests, throws an error if given not-a-class
  * @method throwOnInvalidClass
  * @param {String} x - a possibly valid class name
  * @private
   */
  __private('throwOnInvalidClass', function(x) {
    if (x == null) {
      throw new TypeError("Expected class to be defined.");
    }
    if (!_.isString(x)) {
      throw new TypeError("Expected class to be string.");
    }
    if (!this.isValidClass(x)) {
      throw new TypeError("Expected class to be one of [ " + (auteur._classes.join(', ')) + " ].");
    }
  });
  capitalize = function(x) {
    var capped, first, rest;
    if (_.isString(x)) {
      first = x.substr(0, 1).toUpperCase();
      rest = x.substr(1);
      capped = first + rest;
      return capped;
    }
    return x;
  };

  /**
  * A validator and single location for calling a bunch of possible sub-functions
  * @method create
  * @param {String} kind - create what kinda thing?
   */
  __public('create', function(kind) {
    var args, methodName;
    this.throwOnInvalidClass(kind);
    args = _.rest(arguments);
    console.log(">> auteur create " + kind);
    methodName = '_create' + capitalize(kind);
    if (this[methodName] != null) {
      return this[methodName].apply(this, args);
    }
    throw new Error("Expected " + methodName + " to be valid method.");
  });
  __private('_createProject', function() {
    return console.log("createProject", arguments);
  });
  __private('_createPost', function() {
    return console.log("createPost", arguments);
  });
  __private('_createAuthor', function() {
    return console.log("createAuthor", arguments);
  });
  __private('_createBookmark', function() {
    return console.log("createBookmark", arguments);
  });
  __public('test', function(kind) {
    var args, methodName;
    this.throwOnInvalidClass(kind);
    args = _.rest(arguments);
    console.log(">> auteur test " + kind);
    methodName = '_test' + capitalize(kind);
    if (this[methodName] != null) {
      return this[methodName].apply(this, args);
    }
    throw new Error("Expected " + methodName + " to be valid method.");
  });
  __private('_testProject', function() {
    return console.log("testProject", arguments);
  });
  __private('_testPost', function() {
    return console.log("testPost", arguments);
  });
  __private('_testAuthor', function() {
    return console.log("testAuthor", arguments);
  });
  __private('_testBookmark', function() {
    return console.log("testBookmark", arguments);
  });
  return exports;
}).call(this);
