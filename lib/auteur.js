// Generated by CoffeeScript 1.7.1
(function() {
  "use strict";

  /*
  DEPENDENCIES
   */
  var Deferred, auteur, capitalize, classConstants, emitter, events, fileConstants, fs, postpone, promise, _, __constant, __define, __hidden, __hiddenContext, __lookupHidden, __mutable, __private, __protected, __public, __writable;
  _ = require('lodash');
  events = require('events');
  emitter = new events.EventEmitter();
  promise = require('promised-io');
  Deferred = promise.Deferred;
  fs = require('fs');
  postpone = function() {
    var d;
    d = new Deferred();
    d.yay = _.once(d.resolve);
    d.nay = _.once(d.reject);
    return d;
  };

  /**
  * The Auteur is the automaton that manages the differences between different implementations.
  * It behaves as a singleton (per thread/process), and is modeled after gulp and winston.
  * @class Auteur
   */
  auteur = exports;
  require('pkginfo')(module, 'version');

  /*
  PROPERTY DEFINITIONS!
   */
  __define = function(prop, value, settings, onObject) {
    if (onObject == null) {
      onObject = auteur;
    }
    settings = _.assign({
      enumerable: true,
      writable: true,
      configurable: true
    }, settings);
    if (value != null) {
      settings.value = value;
    }
    return Object.defineProperty(onObject, prop, settings);
  };
  __mutable = function(prop, value) {
    return __define(prop, value);
  };
  __private = function(prop, value) {
    var settings;
    settings = {
      enumerable: false,
      writable: true,
      configurable: false
    };
    return __define(prop, value, settings);
  };
  __public = function(prop, value) {
    var settings;
    settings = {
      enumerable: true,
      writable: false,
      configurable: false
    };
    return __define(prop, value, settings);
  };
  __writable = function(prop, value) {
    var settings;
    settings = {
      enumerable: true,
      writable: true,
      configurable: false
    };
    return __define(prop, value, settings);
  };
  __constant = function(prop, value) {
    var settings;
    settings = {
      enumerable: false,
      writable: false,
      configurable: false
    };
    return __define(prop, value, settings);
  };
  __protected = function(prop, value) {
    var settings;
    return settings = {
      enumerable: false,
      writable: false,
      configurable: true
    };
  };
  __hiddenContext = {};
  __hidden = function(prop, value) {
    if (__hiddenContext[prop] == null) {
      __define(prop, value, {}, __hiddenContext);
      return true;
    }
    return false;
  };
  __lookupHidden = function(key) {
    if (__hiddenContext[key] != null) {
      return __hiddenContext[key];
    }
    return void 0;
  };

  /*
  CONSTANTS
   */
  classConstants = {
    _CLASS_PROJECT: 'project',
    _CLASS_POST: 'post',
    _CLASS_AUTHOR: 'author',
    _CLASS_BOOKMARK: 'bookmark'
  };
  fileConstants = {
    _FILE_CONFIG: '.raconfig'
  };
  _(classConstants).merge(fileConstants).each(function(value, key) {
    return __constant(key, value);
  });

  /**
  * classes constant, for array convenience
  * @property _classes
  * @type Array
   */
  __constant('_classes', _.values(classConstants));
  _(emitter).methods().each(function(fxName) {
    return __public(fxName, function() {
      return emitter[fxName].apply(auteur, arguments);
    });
  });

  /**
  * Checks a given classname against our _classes listing
  * @method isValidClass
  * @param {String} className - a possibly valid class name
  * @return {Boolean} validClass
   */
  __public('isValidClass', function(className) {
    if (!_.isString(className)) {
      return false;
    }
    return _.contains(auteur._classes, className.toLowerCase());
  });

  /**
  * As the name suggests, throws an error if given not-a-class
  * @method throwOnInvalidClass
  * @param {String} x - a possibly valid class name
  * @private
   */
  __private('throwOnInvalidClass', function(x) {
    if (x == null) {
      throw new TypeError("Expected class to be defined.");
    }
    if (!_.isString(x)) {
      throw new TypeError("Expected class to be string.");
    }
    if (!this.isValidClass(x)) {
      throw new TypeError("Expected class to be one of [ " + (auteur._classes.join(', ')) + " ].");
    }
  });
  capitalize = function(x) {
    var capped, first, rest;
    if (_.isString(x)) {
      first = x.substr(0, 1).toUpperCase();
      rest = x.substr(1);
      capped = first + rest;
      return capped;
    }
    return x;
  };

  /**
  * A validator and single location for calling a bunch of possible sub-functions
  * @method create
  * @param {String} kind - create what kinda thing?
   */
  __public('create', function(kind) {
    var args, methodName;
    this.throwOnInvalidClass(kind);
    args = _.rest(arguments);
    console.log(">> auteur create " + kind);
    methodName = '_create' + capitalize(kind);
    if (this[methodName] != null) {
      return this[methodName].apply(this, args);
    }
    throw new Error("Expected " + methodName + " to be valid method.");
  });
  __private('_createProject', function() {
    return console.log("createProject", arguments);
  });
  __private('_createPost', function() {
    return console.log("createPost", arguments);
  });
  __private('_createAuthor', function() {
    return console.log("createAuthor", arguments);
  });
  __private('_createBookmark', function() {
    return console.log("createBookmark", arguments);
  });
  __public('test', function(kind) {
    var args, methodName;
    this.throwOnInvalidClass(kind);
    args = _.rest(arguments);
    console.log(">> auteur test " + kind);
    methodName = '_test' + capitalize(kind);
    if (this[methodName] != null) {
      return this[methodName].apply(this, args);
    }
    throw new Error("Expected " + methodName + " to be valid method.");
  });
  __private('_testProject', function() {
    return console.log("testProject", arguments);
  });
  __private('_testPost', function() {
    return console.log("testPost", arguments);
  });
  __private('_testAuthor', function() {
    return console.log("testAuthor", arguments);
  });
  __private('_testBookmark', function() {
    return console.log("testBookmark", arguments);
  });
  __mutable('exclusions', ['node_modules', '.git', '.svn']);
  __mutable('fileHooks', [auteur._FILE_CONFIG]);
  __constant('_CONFIG_CONSTANT', {
    project: '',
    user: {
      name: '',
      fullname: ''
    },
    directories: {
      posts: 'posts',
      assets: 'assets'
    }
  });
  __mutable('config', _.assign(auteur._CONFIG_CONSTANT, {}));
  __constant('_FLAGS', {
    project: 'p',
    posts: 'o',
    assets: 'a'
  });
  __private('_normalizeFlags', function(flagObject) {
    var flags, inverted, keys, normalized, self;
    self = this;
    keys = _.keys(this._FLAGS);
    flags = _.values(this._FLAGS);
    inverted = _.invert(this._FLAGS);
    return normalized = _(flagObject).map(function(value, key) {
      var longFlag, normal;
      normal = {};
      if (_.contains(keys, key) || _.contains(flags, key)) {
        longFlag = inverted[key];
        if (longFlag == null) {
          longFlag = inverted[self._FLAGS[key]];
        }
        normal[longFlag] = value;
      }
      return normal;
    }).compact().reduce(function(carrier, value, index, carried) {
      carrier[_(value).keys().first()] = _(value).values().first();
      return carrier;
    }, {});
  });
  __public('invoke', function(settings) {
    var self;
    self = this;
    if (settings.project != null) {
      self.config.project = settings.project;
    }
    if (settings.posts != null) {
      self.config.posts = settings.posts;
    }
    if (settings.assets != null) {
      self.config.assets = settings.assets;
    }
    return console.log("invocation vacation", self);
  });
  __public('cli', function() {
    var argv;
    argv = require('minimist')(process.argv.slice(2));
    argv = this._normalizeFlags(argv);
    return auteur.invoke(argv);
  });
  __private('_generateConfig', function(where) {
    var d, filename, self;
    d = postpone();
    filename = where + '/.raconfig';
    self = this;
    fs.writeFile(filename, JSON.stringify(this.config, null, 4), function(err) {
      if (err != null) {
        d.nay(err);
      }
      self.emit('file:written', filename);
      self.emit('file:written:config', true);
      return d.yay(filename);
    });
    return d;
  });
  __private('_readConfig', function(file) {
    var d, self;
    d = postpone();
    self = this;
    fs.readFile(file.path, 'utf8', function(err, obj) {
      var data;
      if (err) {
        d.nay(err);
        return;
      }
      data = JSON.parse(obj);
      console.log("this is the data in the config object!", data);
      self.config = data;
      d.yay(data);
    });
    return d;
  });
  __public('rebuild', function(path, exclusions, announce) {
    var self;
    if (path == null) {
      path = process.cwd();
    }
    if (exclusions == null) {
      exclusions = this.exclusions;
    }
    if (announce == null) {
      announce = [];
    }
    self = this;
    announce = _.union(announce, this.fileHooks);
    this.once('file:match', function(match) {
      if (match.name === self._FILE_CONFIG) {
        console.log("found a magic config file!", match);
        return self._readConfig(match).then(function(data) {
          return console.log("the files are in the computer?!?", data);
        }, function(err) {
          console.log("the files aren't in the computer", err);
          if (err.stack != null) {
            return console.log(err.stack);
          }
        });
      }
    });
    return this._spiderDirectory(path, exclusions, announce);
  });

  /**
  * 
  * @method _spiderDirectory
  * @param {String} location - the directory to walk
  * @param {Array} exclusions - an array of file/dirnames to exclude from the walk
  * @param {Array} announce - an array of file/dirnames to announce when found
   */
  __private('_spiderDirectory', function(location, exclude, announce) {
    var absolutePathWalk, d, self, walk;
    self = this;
    if (exclude == null) {
      exclude = [];
    }
    if (announce == null) {
      announce = [];
    }
    d = postpone();
    walk = function(dir, done) {
      var results;
      results = [];
      return fs.readdir(dir, function(err, list) {
        var pending;
        if (err) {
          return done(err);
        }
        list = _.pull.apply(_, [list].concat(exclude));
        pending = list.length;
        if (!pending) {
          return done(null, results);
        }
        return _(list).each(function(file) {
          var filename;
          filename = file;
          file = "" + dir + "/" + file;
          return fs.stat(file, function(err, stat) {
            if (_.contains(announce, filename)) {
              self.emit('file:match', {
                path: file,
                name: filename,
                stat: stat
              });
              self.emit("file:match:" + filename, {
                path: file,
                name: filename,
                stat: stat
              });
            }
            if (stat != null ? typeof stat.isDirectory === "function" ? stat.isDirectory() : void 0 : void 0) {
              return walk(file, function(err, res) {
                if (err != null) {
                  return done(err);
                }
                results = results.concat(res);
                if (!--pending) {
                  return done(null, results);
                }
              });
            } else {
              results.push(file);
              if (!--pending) {
                return done(null, results);
              }
            }
          });
        });
      });
    };
    absolutePathWalk = function(err, path) {
      if (err != null) {
        return d.nay(err);
      }
      return walk(path, function(err, out) {
        if (err) {
          return d.nay(err);
        }
        return d.yay(out);
      });
    };
    fs.realpath(location, absolutePathWalk);
    return d;
  });
  return exports;
}).call(this);
